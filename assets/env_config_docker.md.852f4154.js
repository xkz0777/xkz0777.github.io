import{_ as s,o as e,c as a,V as o}from"./chunks/framework.e802ca17.js";const y=JSON.parse('{"title":"服务器上使用 Docker","description":"","frontmatter":{},"headers":[],"relativePath":"env_config/docker.md","filePath":"env_config/docker.md","lastUpdated":1697446417000}'),n={name:"env_config/docker.md"},l=o(`<h1 id="服务器上使用-docker" tabindex="-1">服务器上使用 Docker <a class="header-anchor" href="#服务器上使用-docker" aria-label="Permalink to &quot;服务器上使用 Docker&quot;">​</a></h1><h2 id="使用-gpu" tabindex="-1">使用 GPU <a class="header-anchor" href="#使用-gpu" aria-label="Permalink to &quot;使用 GPU&quot;">​</a></h2><p>需要在 <code>docker run</code>（或 <code>docker create</code>，下同）命令中加上参数 <code>--gpus all</code>，启动 container 后输入 <code>nvidia-smi -L</code> 可以检查是否配置成功。</p><h2 id="挂载目录下的权限问题" tabindex="-1">挂载目录下的权限问题 <a class="header-anchor" href="#挂载目录下的权限问题" aria-label="Permalink to &quot;挂载目录下的权限问题&quot;">​</a></h2><p>创建容器时 <code>-v</code> 参数可以将本地目录挂载到容器上，但容器运行时使用的是 root 身份，如果使用 docker 在挂载目录下创建了文件，文件的所有者就是 <code>root</code>，退出 docker 后便无法进行修改。</p><p>解决方案：</p><ul><li><p>已经创建：</p><p>需要在 docker 内用 <code>chown</code> 命令修改所有者，例如：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">chown</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-R</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">ui</span><span style="color:#ABB2BF;">d&gt;</span><span style="color:#98C379;">:</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#98C379;">gi</span><span style="color:#ABB2BF;">d&gt; &lt;</span><span style="color:#98C379;">director</span><span style="color:#ABB2BF;">y&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>还未创建：</p><p>首先保存当前容器：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">docker</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">commit</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">container_nam</span><span style="color:#ABB2BF;">e&gt; &lt;</span><span style="color:#98C379;">image_nam</span><span style="color:#ABB2BF;">e&gt;</span><span style="color:#98C379;">:</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#98C379;">ta</span><span style="color:#ABB2BF;">g&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后在 <code>docker run</code> 命令中加上参数 <code>-u &lt;uid&gt;</code> 重新创建容器。不过这样创建的容器里，prompt 中的 username 会是 &quot;I have no name!&quot;（因为 docker 并不知道宿主机的用户）。虽然能用但是看起来很难受，可以选择在 <code>docker run</code> 命令中加上 <code>-v /etc/passwd:/etc/passwd:ro</code>，或是在 <code>Dockerfile</code> 中加上</p><div class="language-dockerfile line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#61AFEF;">RUN</span><span style="color:#ABB2BF;"> useradd -u &lt;uid&gt; -m &lt;username&gt;</span></span>
<span class="line"><span style="color:#61AFEF;">USER</span><span style="color:#ABB2BF;"> &lt;username&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><h2 id="从容器中下载文件到宿主机" tabindex="-1">从容器中下载文件到宿主机 <a class="header-anchor" href="#从容器中下载文件到宿主机" aria-label="Permalink to &quot;从容器中下载文件到宿主机&quot;">​</a></h2><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">docker</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">cp</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">container_nam</span><span style="color:#ABB2BF;">e&gt;</span><span style="color:#98C379;">:</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#98C379;">source_pat</span><span style="color:#ABB2BF;">h&gt; &lt;</span><span style="color:#98C379;">dest_pat</span><span style="color:#ABB2BF;">h&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/dwqy11/article/details/109384445" target="_blank" rel="noreferrer">https://blog.csdn.net/dwqy11/article/details/109384445</a></li><li><a href="https://forums.docker.com/t/error-i-have-no-name-occurs-when-trying-to-run-sudo-docker-run-volume/117963/8" target="_blank" rel="noreferrer">https://forums.docker.com/t/error-i-have-no-name-occurs-when-trying-to-run-sudo-docker-run-volume/117963/8</a></li></ul>`,11),r=[l];function t(c,p,d,i,u,B){return e(),a("div",null,r)}const m=s(n,[["render",t]]);export{y as __pageData,m as default};
